/**
 * \file chaosmap.hpp
 * \brief Definitions for chaos maps, used in chaotic contexts to generate sequences of chaotic sequences.
 */

#ifndef _CHAOSMAP_HPP_
#define _CHAOSMAP_HPP_

#include "point.hpp"

#include <functional>

namespace Swarm
{
    /**
     * \brief Type definition for a chaos map function.
     * \tparam T The data type for the coordinates (default is float).
     * \tparam dim The dimensionality of the points (default is 2).
     * \see Point
     *
     * Instances of this type represents functions that take a Point and an integer (iteration count) as input and return a new Point.
     */
    template <typename T = float, int dim = 2>
    using MapFunction = std::function<Point<T, dim>(const Point<T, dim> &, int)>;

    /**
     * \brief Class representing a chaos map.
     * \tparam T The data type for the coordinates (default is float).
     * \tparam dim The dimensionality of the points (default is 2).
     * \see Point
     * \see MapFunction
     *
     * This class encapsulates a chaos map function along with methods to transform points between different coordinate domains.
     */
    template <typename T = float, int dim = 2>
    class ChaosMap
    {
    private:
        /**
         * \brief The mapper function used to generate new points.
         */
        MapFunction<T, dim> map;

        /**
         * \brief The minimum point defining the domain over which the map operates.
         */
        Point<T, dim> a_min;

        /**
         * \brief The maximum point defining the domain over which the map operates.
         */
        Point<T, dim> b_max;

        /**
         * \brief Maps a point from one domain to another.
         * \param point The point to be mapped.
         * \param first_range_start The start of the original domain.
         * \param first_range_end The end of the original domain.
         * \param min_range The start of the target domain.
         * \param max_range The end of the target domain.
         * \return A new point mapped to the target domain.
         * \see Point
         */
        inline Point<T, dim> mapBetweenDomains(const Point<T, dim> &point, const Point<T, dim> &first_range_start, const Point<T, dim> &first_range_end, const Point<T, dim> &min_range, const Point<T, dim> &max_range) const
        {
            // codice per trasformare le coordinate
            return (point - first_range_start) / (first_range_end - first_range_start) * (max_range - min_range) + min_range;
        };

        /**
         * \brief Generates a new point using the chaos map function.
         * \param point The input point.
         * \param iter The current iteration count.
         * \return A new point generated by the chaos map function.
         * \see MapFunction
         */
        inline Point<T, dim> generatePoint(const Point<T, dim> &point, int iter) const
        {
            // map evaluate point map(Point),per ogni dimensione genera per ogni coordinata
            return map(point, iter);
        };

    public:
        /**
         * \brief Constructs a ChaosMap with the given map function and domain boundaries.
         * \param lambda_fun The chaos map function.
         * \param min The minimum point defining the domain.
         * \param max The maximum point defining the domain.
         * \see MapFunction
         * \see Point
         */
        ChaosMap(const MapFunction<T, dim> &lambda_fun, const Point<T, dim> &min, const Point<T, dim> &max) : map(lambda_fun), a_min(min), b_max(max) {};

        /**
         * \brief Transforms a point from the Global domain to the Local domain.
         * \param point The point to be transformed.
         * \param min_range The minimum point defining the Global domain.
         * \param max_range The maximum point defining the Global domain.
         * \return A new point in the Local domain.
         * \see Point
         * \see mapBetweenDomains
         */
        inline Point<T, dim> toLocalDomain(const Point<T, dim> &point, const Point<T, dim> &min_range, const Point<T, dim> &max_range) const
        {
            return mapBetweenDomains(point, min_range, max_range, a_min, b_max);
        };

        /**
         * \brief Transforms a point from the Local domain to the Global domain.
         * \param point The point to be transformed.
         * \param min_range The minimum point defining the Global domain.
         * \param max_range The maximum point defining the Global domain.
         * \return A new point in the Global domain.
         * \see Point
         * \see mapBetweenDomains
         */
        inline Point<T, dim> toGlobalDomain(const Point<T, dim> &point, const Point<T, dim> &min_range, const Point<T, dim> &max_range) const
        {
            return mapBetweenDomains(point, a_min, b_max, min_range, max_range);
        };

        /**
         * \brief Generates a new point by applying the chaos map to a given point, transforming it between Global and Local domains.
         * \param point The input point in the Global domain.
         * \param min_global The minimum point defining the Global domain.
         * \param max_global The maximum point defining the Global domain.
         * \param iter The current iteration count.
         * \return A new point in the Global domain after applying the chaos map.
         * \see Point
         * \see toLocalDomain
         * \see generatePoint
         * \see toGlobalDomain
         */
        inline Point<T, dim> getPoint(const Point<T, dim> &point, const Point<T, dim> &min_global, const Point<T, dim> &max_global, int iter) const
        {
            Point<T, dim> new_point = toLocalDomain(point, min_global, max_global);
            new_point = generatePoint(new_point, iter);
            new_point = toGlobalDomain(new_point, min_global, max_global);

            return new_point;
        };
    };
    namespace ChaosFactory
    {
        // Chebyshev ChaosMap xk+1​=cos(arccos(xk​)*k),xk​∈[−1,1]
        template <typename T = float, int dim = 2>
        class Chebyshev : public ChaosMap<T, dim>
        {
        public:
            Chebyshev()
                : ChaosMap<T, dim>(
                      [](const Point<T, dim> &p, int k)
                      {
                          return (p.arccos() * k).cos();
                      },
                      Point<T, dim>(-1.f),
                      Point<T, dim>(1.f))
            {
            }
        };

        // Singer ChaosMap xk+1​=μ(7.86xk​−23.31xk2​+28.75xk3​−13.302875xk4​) where mu(0,1]
        template <typename T = float, int dim = 2>
        class Singer : public ChaosMap<T, dim>
        {
            static T normalize_mu(T mu)
            {
                if (mu > static_cast<T>(0) && mu <= static_cast<T>(1))
                    return mu;
                return static_cast<T>(1);
            }

        public:
            Singer(T mu_in = static_cast<T>(1))
                : ChaosMap<T, dim>(
                      [mu = normalize_mu(mu_in)](const Point<T, dim> &p, int)
                      {
                          const T a = static_cast<T>(7.86);
                          const T b = static_cast<T>(-23.31);
                          const T c = static_cast<T>(28.75);
                          const T d = static_cast<T>(-13.302875);
                          return (p * a + p.pow(2) * b + p.pow(3) * c + p.pow(4) * d) * mu;
                      },
                      Point<T, dim>(0.f),
                      Point<T, dim>(1.f))
            {
            }
        };

        // Sine ChaosMap xk+1​=a*sin(πxk​) a(0,1]
        template <typename T = float, int dim = 2>
        class Sine : public ChaosMap<T, dim>
        {
            static T normalize_a(T a)
            {
                if (a > static_cast<T>(0) && a <= static_cast<T>(1))
                    return a;
                return static_cast<T>(1);
            }

        public:
            Sine(T a_in = static_cast<T>(1))
                : ChaosMap<T, dim>(
                      [a = normalize_a(a_in)](const Point<T, dim> &p, int)
                      {
                          const T pi = static_cast<T>(std::numbers::pi);
                          return (p * pi).sin() * a;
                      },
                      Point<T, dim>(0.f),
                      Point<T, dim>(1.f))
            {
            }
        };

        // Sinusoidal ChaosMap xk+1​=axk2​sin(πxk​) a(0,1]
        template <typename T = float, int dim = 2>
        class Sinusoidal : public ChaosMap<T, dim>
        {
            static T normalize_a(T a)
            {
                if (a > static_cast<T>(0) && a <= static_cast<T>(1))
                    return a;
                return static_cast<T>(1);
            }

        public:
            Sinusoidal(T a_in = static_cast<T>(1))
                : ChaosMap<T, dim>(
                      [a = normalize_a(a_in)](const Point<T, dim> &p, int)
                      {
                          const T pi = static_cast<T>(std::numbers::pi);
                          return (p * pi).sin() * p * p * a;
                      },
                      Point<T, dim>(0.f),
                      Point<T, dim>(1.f))
            {
            }
        };

        // LogisticMap ChaosMap xk+1​=μxk​(1−xk​) mu(0,4]
        template <typename T = float, int dim = 2>
        class LogisticMap : public ChaosMap<T, dim>
        {
            static T normalize_mu(T mu)
            {
                if (mu > static_cast<T>(0) && mu <= static_cast<T>(4))
                    return mu;
                return static_cast<T>(4);
            }

        public:
            LogisticMap(T mu_in = static_cast<T>(4))
                : ChaosMap<T, dim>(
                      [mu = normalize_mu(mu_in)](const Point<T, dim> &p, int)
                      {
                          return (Point<T, dim>(1.f) - p) * p * mu;
                      },
                      Point<T, dim>(0.f),
                      Point<T, dim>(1.f))
            {
            }
        };
        // Iterative ChaosMap xk+1​=sin(​aπ/xk​) a>0
        template <typename T = float, int dim = 2>
        class Iterative : public ChaosMap<T, dim>
        {
            static T normalize_a(T a)
            {
                if (a > static_cast<T>(0))
                    return a;
                return static_cast<T>(1);
            }

        public:
            Iterative(T a_in = static_cast<T>(1))
                : ChaosMap<T, dim>(
                      [a = normalize_a(a_in)](const Point<T, dim> &p, int)
                      {
                          const T pi = static_cast<T>(std::numbers::pi);
                          return (Point<T, dim>(a * pi) / p).sin();
                      },
                      Point<T, dim>(-1.f),
                      Point<T, dim>(1.f))
            {
            }
        };
        // Tent ChaosMap
        /*
            template <typename T = float, int dim = 2>
        class Tent : public ChaosMap<T, dim>
        {
        public:
            Tent()
                : ChaosMap<T, dim>(
                      [](const Point<T, dim> &p, int k)
                      {
                            //T mu = static_cast<T>(0.7);
                          //if(p<mu)
                            //return p/Point<T, dim>(0.7f);
                          //else
                            return (Point<T, dim>(1.f)-p)*Point<T, dim>(10/3.f);

                      },
                      Point<T, dim>(0.f),
                      Point<T, dim>(1.f))
            {
            }
        };
        */

    };

};

#endif